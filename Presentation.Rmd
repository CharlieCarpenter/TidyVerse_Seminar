---
title: "Intro to Tidyverse"
author: "Charlie Carpenter"
output: html_document
---

https://rviews.rstudio.com/2017/06/08/what-is-the-tidyverse/#:~:text=The%20tidyverse%20is%20a%20coherent,being%20expanded%20by%20several%20contributors.

## Introduction

```{r, message=FALSE}
# install.packages('tidyverse'); install.packages('magrittr') 
library(tidyverse); library(magrittr)
```

#### What is the 'tidyverse'?

  The tidyverse is a collection of packages that are designed to work together to enhance any data cleaning, visualization, and analysis workflow. It is an enormous library of evolving packages and functions designed by Hadley Wickham and implemented in R. Packages in the tidyverse include `ggplot2` (visualizations), `dplyr` (data manipulation), `tidyr` (data manipulation), `readr` (data imports), `purrr` (functional programming), `tibble` (advanced data frames), `magrittr` (piping operations), `stringr` (advanced string operations), `lubridate` (advanced date operations), `forcats` (advanced factor operations), `modelr` (pipelines for modelling), `broom` (tidy model output), and many others.

#### Why use the 'tidyverse'?

  The tidyverse doesn't provide any new functionality to R. In fact, most of the operations you would perform using the tidyverse are available through `base` R or the `stats` package. The primary goal of the tidyverse is to provide helpful wrappers for common operations that all work together, providing more **coherent and readable** code.

  Wickham often quotes famous computer scientist Hal Abelson when discussing his philosophy for tidyverse code: 

> “Programs must be written for people to read 
> and only incidentally for machines to execute”. 
>
> `r tufte::quote_footer('--- Hal Abelson')`

  Code can easily become cumbersome to read using only `base` code,
```{r}
unlist(tapply(mtcars[mtcars$vs == 0, ]$mpg, mtcars[mtcars$vs == 0, ]$cyl, range))
```

or we need to create multiple objects to delineate steps.
```{r}
mtcars0 <- mtcars[mtcars$vs == 0, ]
mt.ranges <- tapply(mtcars0$mpg, mtcars0$cyl, range)

do.call(rbind, mt.ranges)
```

  The tidyverse provides readable code without the need to nest functions or name multiple objects:
```{r}
mtcars %>% 
  filter(vs == 0) %>% 
  group_by(cyl) %>% 
  summarise(range(mpg), .groups = 'drop')
```

## Overview

  The tidyverse is very big, so we won't be able to cover everything. In this presentation we will focus on data visualization using `ggplot2`, new coding syntax using *pipe* operators, and `dplyr`/`tidyr` for data manipulation.

## Plotting

  One of the first entries in the tidyverse was the `ggplot2` package. There are many methods to crest plots within R, but `ggplot2` claims to be "one of the most elegant and most versatile" packages. I tend to agree :). 
  
  `ggplot2` works on the principle of "layered graphics," in which different elements are layered on top of one another to tell a story greater than the sum of their individual parts. If you're interested in data visualization, Wickham's paper on the [theory of layered graphics](http://vita.had.co.nz/papers/layered-grammar.pdf) might be of interest. 
  
  We will be walking through some examples using the `mpg` dataset from the `ggplot2` package.
  
```{r}
mpg ## Dataset from the ggplot2 package
```
  
### Creating a ggplot2

  `ggplot2` works by creating a base 'layer' with the `ggplot` function, and then adding specific plotting layers onto the base plot. These layers are called **geoms**, and there are several to chose from.
  
  Lets start by creating a simple scatterplot of cars' mpg on the highway, `hwy`, by the cars engine size in litres, `displ`.

```{r}
ggplot(data = mpg) + # base plot
  geom_point(mapping = aes(x = displ, y = hwy)) # specifying points
```

### Basic Aesthetics

  The true power of `ggplot2` (in my opinion) comes from the flexibility of the `aes` function. This piece controls the *aesthetics* of the graph. We can use this function to specify **color**,
  
```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, color = drv)) 
```

**shape**,

```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, shape = drv)) 
```

and **size** of plotting aspects.

```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, size = drv)) 
```

We can also add in multiple aesthetics for clearer groupings.

```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, 
                           shape = drv, color = drv)) 
```

### Smoothers

  A great addition from `ggplot2` is it's built in smoother functions. The default for smaller data sets is to use a *loess* smoother. Other available options include "gam", "lm", "glm", and others. 
  
```{r}
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, color = drv)) 
```

```{r}
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, color = drv),
              method = 'lm', se = FALSE) # Linear model, no error bars
```

### Layering

  I mentioned earlier that `ggplot2` is built using a theory of "layered graphics." In practice, this means we can "layer" multiple geoms! We do this by stringing together multiple geoms using a `+` between each layer.
  
```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy,
                            shape = drv, color = drv)) +
  geom_smooth(mapping = aes(x = displ, y = hwy, color = drv),
              show.legend = FALSE) ## Surpress this legend 
```
  
  There is a lot of flexibile customization option available through `ggplot2` package. 
  
```{r}
ggplot(data = mpg, 
       aes(x = displ, y = hwy, color = drv) # 'Global' aesthetics
       ) +
  geom_point(aes(shape = drv) # 'Geom specific' aesthetic
             ) +
  geom_smooth(aes(linetype = drv),
              show.legend = FALSE) + # Surpress this legend 
  facet_wrap(~ drv) + # Create subplots by a variable
  labs(title = "Title", subtitle = 'sub', caption = 'caption',
       y = "MPG on Highway", x = "Engine Size (L)") + # Custom Labels
  theme_bw() # New plot theme
```

### Other Plot Types

  Obviously, we can make more than just scatterplots. Below are two examples of other plots styles available in `ggplot2`
  
**Boxplots**

```{r}
ggplot(mpg, aes(x=class, y=hwy, fill = class)) + # 'Global' aes
  geom_boxplot() + # make a boxplot
  theme_minimal() # 'minimal' theme
```

**Bar Charts**

```{r}
ggplot(mpg, aes(x=class, y=hwy, fill = drv)) + # 'Global' aes
  geom_col() + # make a boxplot
  theme_classic()
```
  
### Extentions

  Since R is an open source software with a very active community, many programmers have created plotting packages with custom geoms for plotting different data in the style of `ggplot2`. A few examples include `ggtree` for (phylogenetic) trees, `ggdendro` for generic dendrograms, `ggrepel` for labeling, and `ggnetwork` for network/graph data.

## The 'pipe' function
  
  The *pipe* function, ``%>%`` is a key facet of the tidyverse from the `magrittr` package. It works similarly to other in line functions such as ``%in%``, ``%*%``, or ``%%``. Except instead of performing a function on two objects, it takes the object on the left and moves it to the first argument of the function on the right.
  
```{r}
mtcars %>% head()
```

  The *pipe* is also able to place the left hand object anywhere in the right hand function you specify with a `.`.
  
```{r, eval = FALSE}
mtcars %>% lm(mpg~cyl, data = .) 
```

  There are multiple piping functions available in the `magrittr` package: `%<>%`, `%T>%`, `%$%`. We won't cover these, but they each have interesting functionality that can be very helpful.

  This seems like an unnecessary step, but, when stringing multiple operations together, it becomes an essential tool to keep code readable. The format for adding *geoms* to a `ggplot` was an early formulation of this idea of stringing multiple functions together through an external function.

## Examples of base functions and tidyverse

  As we said earlier, there aren't many things you can do with the tidyverse that you can't do with `base` R. In fact, the tidyverse is mostly built out of `base` R (and a little `Rcpp`), like R is built out of C code.
  
### Extracting Variables  
  
##### Base Extraction

  We're all familiar with extraction methods in `base`. 

```{r}
## First column as vector
mtcars[,1] 
## or
mtcars[,'mpg']
## or
mtcars$mpg
## or (unnecessarily)
getElement(mtcars, 'mpg')
```

  We can also maintain the original dimension of the object using `drop = FALSE` or selecting multiple columns.

```{r}
head( mtcars[,1, drop = FALSE] )
```

```{r}
head( mtcars[,1:2] )
```

##### Tidyverse Extraction

  tidyverse provides the `pull` and `select` functions to replace the extractors from `base`. `pull` is used to extract a *single* column and simplify it to a vector, and `select` is used to extract *one or more* columns and maintain the data's original structure (i.e. data.frames remain data.frames). 

```{r}
## First column as vector
pull(mtcars, 1)
## or with the 'pipe'
mtcars %>% pull(1)
mtcars %>% pull(mpg)
```
  
  We can also maintain the data.frame structure using the `select` function from the *dplyr* package. 
  
```{r, eval = F}
select(mtcars, 1)
## or selecting multiple cols
select(mtcars, 1,2,3)
## equivalently
mtcars %>% select(1:3)
```

  The `select` function also gives the user flexible and intuitive functions for selecting ranges, complements, intersections and unions, or specifying selection through regular expressions with helper functions.
  
```{r, eval = FALSE}
## Selecting a vars 'mpg', 'cyl', 'disp', and 'hp'
mtcars %>% select(mpg:hp)

## Selecting using regular expression helper functions
mtcars %>% 
  select(starts_with('d')) ## all variables that start with 'd'

mtcars %>% 
  select(contains('a')) ## all variables with an 'a' in their name

## Select unions of elements (or intersections with `&`)
mtcars %>% 
  select(starts_with('c') | ends_with('arb'))

## Or rename variables through the `select` function
mtcars %>% 
  select(Miles_Per_Gal = mpg) ## new_name = original_name
```

### Subset and Filter

##### Base

```{r}
subset(mtcars, disp >= mean(disp))
```

  Note that this is one of the few times that base code uses 'none standard evaluation.' This means that it captures input as '*expressions*' to be evaluated within the function's environment, i.e. we don't need to use any *extraction* functions such as `[]` or `$` within the argument. The `subset` function would look like this: `subset(mtcars, mtcars$disp >= mean(mtcars$disp))` if it worked like most `base` functions.

##### Tidyverse

  The tidyverse primarily operates by capturing arguments as *expressions*. This greatly simplifies most of the syntax required and is a major contribution to keeping code 'tidy.' 

```{r}
## Multiple filtering options. 
## Equivalent of multiple '&' statements in subset
mtcars %>% 
  filter(disp >= mean(disp),
         carb == 4,
         vs == 0)
```

### Subset and Extraction

##### Base

```{r}
## Subset data.frame
subset(mtcars, carb == 4, select = c(mpg, cyl, carb))

## Subset to vector
subset(mtcars, carb == 4, select = cyl, drop = TRUE)
```

##### Tidyverse

```{r}
## Subset data.frame
mtcars %>% 
  filter(carb == 4) %>% 
  select(mpg, cyl, carb)

## Subset to vector
mtcars %>% 
  filter(carb == 4) %>% 
  pull(cyl)
```

### Grouped Functions

##### Base


```{r}
tapply(mtcars$mpg, mtcars$cyl, mean)
```

##### Tidyverse

```{r}
mtcars %>% 
  group_by(cyl) %>% 
  summarise(Mean_mpg = mean(mpg))
```

### Split, Apply, Combine

`d_ply`, `_` can be d,a,l, data.frame, array, list.

Can also use `a_ply`, `l_ply`, `m_ply` for different inputs.


[Split-Apply-Combine paper](https://vita.had.co.nz/papers/plyr.pdf)

```{r}
mtcars %>% 
  plyr::ddply(~ cyl, .fun = function(set){
    ## linear model for each cly level
    mod <- lm(mpg ~ disp, data = set) 
    
    ## Model coefficients
    coef(mod)
  })
```


2. merge vs. left_, right_, and full_join

## Syntax
Combine large data operation into one single flow vs. a multistage operation with nested () or multiple names

Phil Karlton - "There are only two hard things in Computer Science: cache invalidation and naming things."

## Advantages

1. Better plotting functions
2. Easier for humans to read and arguably simpler to write
    + *pipe* functions allow us to code how we talk and think

## Disadvantages
1. Still a 'work in progress'. Many functions are continuously changing
    + new `.groups` argument in the `select` function
    + melt/cast -> gather/spread -> pivot_longer/pivot_wider
2. "Rectangular" data structure isn't adopted by everyone. 
    + Bioconductor requires S4 objects



## send out packages / data set

## Talk about context
  ### Better for non-programmers to read

## What to look at to keep learning the tidyverse

[R for Data Science](https://r4ds.had.co.nz/)



## Focus on data cleaning

## Why to switch if at all


## Put this on resume
